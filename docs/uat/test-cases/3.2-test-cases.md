# Test Cases: 3.2 - Entity-Aware Chunking with Section Boundary Detection

**Story**: 3.2
**Generated**: 2025-11-14
**Coverage Level**: standard
**Generated By**: create-test-cases workflow

---

## Story Summary

**As a** data scientist preparing enterprise documents for RAG workflows
**I want** chunks to preserve entity context and align with document sections
**So that** LLM retrievals maintain complete entity definitions and structural coherence without fragmenting critical information

---

## Test Coverage Summary

| AC ID | Description | Happy Path | Edge Cases | Error Cases | Integration | Total Tests |
|-------|-------------|------------|------------|-------------|-------------|-------------|
| AC-3.2-1 | Entity Mentions Kept Within Single Chunks (>95%) | ✓ | ✓ (3) | ✓ (2) | ✓ | 7 |
| AC-3.2-2 | Entities Split Across Chunks Noted in Metadata | ✓ | ✓ (2) | ✓ (1) | ✓ | 5 |
| AC-3.2-3 | Relationship Context Preserved | ✓ | ✓ (2) | ✓ (1) | ✓ | 5 |
| AC-3.2-4 | Chunk Boundaries Avoid Splitting Entity Definitions | ✓ | ✓ (2) | ✓ (1) | ✓ | 5 |
| AC-3.2-5 | Cross-References Maintained with Entity IDs | ✓ | ✓ (1) | - | ✓ | 3 |
| AC-3.2-6 | Entity Tags in Chunk Metadata | ✓ | ✓ (2) | ✓ (1) | - | 4 |
| AC-3.2-7 | Section Boundaries Respected (Deferred AC-3.1-2) | ✓ | ✓ (3) | ✓ (1) | ✓ | 6 |
| AC-3.2-8 | Determinism Maintained | ✓ | ✓ (1) | - | ✓ | 3 |

**Test Type Distribution**:
- Unit tests: 23
- Integration tests: 12
- CLI tests: 0
- Manual tests: 3
- Performance tests: 2
- **Total test cases**: 40

---

## Test Cases

### AC-3.2-1: Entity Mentions Kept Within Single Chunks (>95% Preservation)

#### Test Case TC-3.2-1-1

**Acceptance Criterion**: AC-3.2-1
**Test Type**: Integration
**Scenario**: Happy Path

**Objective**: Validate that entity-aware chunking preserves >95% of entities within single chunks for a typical entity-rich document

**Preconditions**:
- ChunkingEngine initialized with entity_aware=True
- ProcessingResult with 50+ entities (risks, controls, policies) available
- Test fixture: `tests/fixtures/entity_rich_documents/risk_register_sample.md`

**Test Steps**:
1. Load ProcessingResult with normalized entity-rich document (50+ entities)
2. Call ChunkingEngine.chunk_document() with chunk_size=512, overlap_pct=0.15
3. Iterate through all generated chunks
4. For each entity in original ProcessingResult.entities, check if it appears intact in exactly one chunk
5. Calculate preservation rate: (entities_intact / total_entities) * 100

**Expected Results**:
- Preservation rate >95% (target: ≥95%)
- Entities with start_pos and end_pos within single chunk boundaries
- No entity split across multiple chunks unless unavoidable (entity size > chunk_size)

**Test Data**:
- Input: ProcessingResult with 50 entities (mix of RISK-XXX, CTRL-XXX, POLICY-XXX)
- Expected Output: ≥48 entities intact (95% of 50)

**Dependencies**:
- Fixtures: `tests/fixtures/entity_rich_documents/risk_register_sample.md`
- Helpers: `calculate_entity_preservation_rate(chunks, entities)`

---

#### Test Case TC-3.2-1-2

**Acceptance Criterion**: AC-3.2-1
**Test Type**: Unit
**Scenario**: Edge Case - Very Small Chunks

**Objective**: Verify entity preservation behavior when chunk_size is very small (128 tokens)

**Preconditions**:
- EntityPreserver initialized
- ProcessingResult with entities of varying sizes (10-500 characters)

**Test Steps**:
1. Create ProcessingResult with 10 entities (sizes: 50, 100, 150, 200, 300, 400, 500 characters)
2. Initialize ChunkingEngine with chunk_size=128 (very small)
3. Call chunk_document()
4. Verify entities <=128 tokens remain intact
5. Verify entities >128 tokens become single chunks with warning logged

**Expected Results**:
- Small entities (<=128 tokens) preserved intact
- Large entities (>128 tokens) become oversized chunks
- Warning logged for oversized chunks: "Entity exceeds chunk_size, creating oversized chunk"
- Preservation rate calculated correctly (all entities counted as preserved)

**Test Data**:
- Input: 10 entities with sizes 50-500 characters
- Expected Output: 10 chunks total (7 normal + 3 oversized)

---

#### Test Case TC-3.2-1-3

**Acceptance Criterion**: AC-3.2-1
**Test Type**: Unit
**Scenario**: Edge Case - Dense Entity Clusters

**Objective**: Validate chunking behavior when entities are densely clustered with minimal text between them

**Preconditions**:
- Text with 20 entities, average gap between entities = 10 characters

**Test Steps**:
1. Create synthetic text with dense entity clusters (entity every 50 chars, 10 char gaps)
2. Call EntityPreserver.find_entity_gaps()
3. Verify gaps identified correctly (20 gaps, each ~10 chars)
4. Call ChunkingEngine.chunk_document() with chunk_size=512
5. Verify chunks split at entity gaps (not within entities)

**Expected Results**:
- All 20 gaps identified by find_entity_gaps()
- Chunk boundaries align with gaps (between entities)
- No entities split unless gap too small for chunk boundary
- Preservation rate >95%

---

#### Test Case TC-3.2-1-4

**Acceptance Criterion**: AC-3.2-1
**Test Type**: Edge Case - Very Large Single Entity

**Objective**: Verify graceful handling of entity definition larger than chunk_size

**Preconditions**:
- Single entity with definition = 2000 tokens (chunk_size = 512)

**Test Steps**:
1. Create ProcessingResult with one very large entity (2000 tokens)
2. Call ChunkingEngine.chunk_document(chunk_size=512)
3. Verify entity becomes single chunk (size = 2000 tokens, exceeds chunk_size)
4. Verify warning logged
5. Verify chunk metadata includes oversized flag

**Expected Results**:
- Single chunk generated with size=2000 tokens (exceeds target chunk_size=512)
- Warning logged: "Entity definition exceeds chunk_size, creating oversized chunk"
- ChunkMetadata.entity_tags includes entity with is_partial=False (complete entity)
- Preservation rate = 100% (entity intact)

---

#### Test Case TC-3.2-1-5

**Acceptance Criterion**: AC-3.2-1
**Test Type**: Error Case - Overlapping Entities

**Objective**: Verify chunking handles overlapping entity spans without corruption

**Preconditions**:
- ProcessingResult with 2 entities: Entity1 (start=100, end=200), Entity2 (start=150, end=250)

**Test Steps**:
1. Create ProcessingResult with overlapping entities
2. Call EntityPreserver.analyze_entities()
3. Verify both entities analyzed correctly (no crash)
4. Call ChunkingEngine.chunk_document()
5. Verify chunks handle overlapping spans gracefully

**Expected Results**:
- Both entities recognized in ChunkMetadata.entity_tags
- No crash or corruption
- Overlapping region (150-200) included in chunk with both entity tags
- Warning logged about overlapping entities

---

#### Test Case TC-3.2-1-6

**Acceptance Criterion**: AC-3.2-1
**Test Type**: Error Case - Empty Entity List

**Objective**: Verify chunking works correctly when no entities present (fallback to Story 3.1 behavior)

**Preconditions**:
- ProcessingResult with empty entities list

**Test Steps**:
1. Create ProcessingResult with normalized text but entities=[]
2. Call ChunkingEngine.chunk_document(entity_aware=True)
3. Verify chunking falls back to sentence-boundary-only splitting (Story 3.1)
4. Verify no entity metadata populated
5. Verify no errors or warnings

**Expected Results**:
- Chunks generated using sentence boundaries only (no entity awareness)
- ChunkMetadata.entity_tags = [] for all chunks
- No errors, graceful degradation
- Behavior identical to entity_aware=False

---

#### Test Case TC-3.2-1-7

**Acceptance Criterion**: AC-3.2-1
**Test Type**: Integration
**Scenario**: Integration - Real-World Risk Register

**Objective**: End-to-end validation with real anonymized risk register document

**Preconditions**:
- Real-world fixture: `tests/fixtures/entity_rich_documents/anonymized_risk_register.md`
- Document contains 100+ entities (risks, controls, owners, dates)

**Test Steps**:
1. Load anonymized risk register (Epic 2 normalized output)
2. Run ChunkingEngine.chunk_document()
3. Calculate entity preservation rate across all chunks
4. Verify >95% threshold met
5. Generate preservation report (entities intact vs split)

**Expected Results**:
- Preservation rate >95%
- Report shows entity types preserved (RISK: 95%, CTRL: 98%, etc.)
- Integration with Epic 2 normalization successful
- Realistic document validates production readiness

**Dependencies**:
- Fixtures: `tests/fixtures/entity_rich_documents/anonymized_risk_register.md`
- Helpers: `generate_preservation_report(chunks, entities)`

---

### AC-3.2-2: Entities Split Across Chunks Noted in Metadata

#### Test Case TC-3.2-2-1

**Acceptance Criterion**: AC-3.2-2
**Test Type**: Unit
**Scenario**: Happy Path

**Objective**: Verify partial entity metadata populated correctly when entity unavoidably split

**Preconditions**:
- Entity spans 600 tokens, chunk_size=512, entity must be split

**Test Steps**:
1. Create ProcessingResult with large entity (600 tokens)
2. Call ChunkingEngine.chunk_document(chunk_size=512)
3. Identify the two chunks containing split entity
4. Verify Chunk N metadata includes: is_partial=True, entity_continues_in_next=True, next_chunk_id
5. Verify Chunk N+1 metadata includes: is_partial=True, entity_continued_from_previous=True, prev_chunk_id

**Expected Results**:
- Both chunks have is_partial=True for split entity
- Cross-references populated: next_chunk_id in Chunk N, prev_chunk_id in Chunk N+1
- Continuation flags set correctly
- Entity reconstructable from both chunks

**Test Data**:
- Input: Single 600-token entity, chunk_size=512
- Expected Output: 2 chunks with cross-referenced partial entity metadata

---

#### Test Case TC-3.2-2-2

**Acceptance Criterion**: AC-3.2-2
**Test Type**: Edge Case - Multiple Partial Entities in One Chunk

**Objective**: Verify chunk handles multiple partial entities correctly

**Preconditions**:
- Chunk contains end of Entity A and start of Entity B (both partial)

**Test Steps**:
1. Create scenario where chunk boundary splits two adjacent large entities
2. Verify chunk metadata includes two entries in entity_tags:
   - Entity A: is_partial=True, entity_continued_from_previous=True
   - Entity B: is_partial=True, entity_continues_in_next=True
3. Verify cross-references correct for both entities

**Expected Results**:
- ChunkMetadata.entity_tags contains 2 EntityReference objects
- Both flagged is_partial=True
- Continuation flags differ (one from previous, one to next)
- Cross-references accurate

---

#### Test Case TC-3.2-2-3

**Acceptance Criterion**: AC-3.2-2
**Test Type**: Edge Case - Entity Spans Three Chunks

**Objective**: Verify very large entity spanning 3+ chunks tracked correctly

**Preconditions**:
- Entity = 1500 tokens, chunk_size=512 (spans 3 chunks)

**Test Steps**:
1. Create ProcessingResult with 1500-token entity
2. Call chunk_document(chunk_size=512)
3. Verify entity appears in 3 chunks:
   - Chunk N: is_partial=True, continues_in_next
   - Chunk N+1: is_partial=True, continued_from_previous AND continues_in_next
   - Chunk N+2: is_partial=True, continued_from_previous
4. Verify cross-reference chain: N → N+1 → N+2

**Expected Results**:
- 3 chunks contain partial entity
- Middle chunk has dual flags (from previous AND to next)
- Cross-reference chain complete (N → N+1 → N+2)
- Entity reconstructable by following chain

---

#### Test Case TC-3.2-2-4

**Acceptance Criterion**: AC-3.2-2
**Test Type**: Integration
**Scenario**: Integration - Partial Entity Search

**Objective**: Validate cross-chunk entity lookup using cross-references

**Preconditions**:
- Document with 5 split entities (10 chunks with partial entity references)

**Test Steps**:
1. Generate chunks with split entities
2. Implement helper: find_all_chunks_for_entity(entity_id, chunks)
3. For each split entity, verify helper returns all chunks containing entity
4. Verify cross-references enable complete entity reconstruction

**Expected Results**:
- Helper successfully finds all chunks for each entity_id
- Cross-references enable navigation between chunks
- Complete entity text reconstructable from partial chunks
- No broken cross-reference links

**Dependencies**:
- Helpers: `find_all_chunks_for_entity(entity_id, chunks)`

---

#### Test Case TC-3.2-2-5

**Acceptance Criterion**: AC-3.2-2
**Test Type**: Error Case - Missing Cross-Reference

**Objective**: Verify validation catches broken cross-reference chains

**Preconditions**:
- Intentionally corrupt chunk metadata (missing next_chunk_id)

**Test Steps**:
1. Generate chunks with partial entity
2. Remove next_chunk_id from Chunk N metadata (simulate corruption)
3. Run validation helper: validate_entity_cross_references(chunks)
4. Verify validation detects broken chain

**Expected Results**:
- Validation error: "Broken entity cross-reference chain for entity RISK-001"
- Error includes chunk IDs involved
- Validation prevents corrupt chunks from progressing to output stage

**Dependencies**:
- Helpers: `validate_entity_cross_references(chunks)`

---

### AC-3.2-3: Relationship Context Preserved

#### Test Case TC-3.2-3-1

**Acceptance Criterion**: AC-3.2-3
**Test Type**: Integration
**Scenario**: Happy Path

**Objective**: Verify entity relationships (risk → control mappings) preserved within chunks

**Preconditions**:
- Document with 10 risk-control relationship pairs
- Relationships span <512 tokens (fit within chunk_size)

**Test Steps**:
1. Create ProcessingResult with text: "RISK-001 is mitigated by CTRL-042"
2. Call EntityPreserver.detect_entity_relationships()
3. Verify relationship triple detected: (RISK-001, mitigated_by, CTRL-042)
4. Call chunk_document()
5. Verify chunk containing relationship includes both entities
6. Verify ChunkMetadata.entity_relationships includes triple

**Expected Results**:
- Relationship triple detected correctly
- Both entities (RISK-001, CTRL-042) in same chunk
- ChunkMetadata.entity_relationships = [("RISK-001", "mitigated_by", "CTRL-042")]
- Relationship context preserved for RAG retrieval

**Test Data**:
- Input: "RISK-001 is mitigated by CTRL-042. The control implements..."
- Expected Output: Chunk with both entities + relationship triple

---

#### Test Case TC-3.2-3-2

**Acceptance Criterion**: AC-3.2-3
**Test Type**: Unit
**Scenario**: Edge Case - Multiple Relationship Types

**Objective**: Verify detection of various relationship keywords (mitigated_by, maps_to, implements, addresses)

**Preconditions**:
- Text with 4 relationship types

**Test Steps**:
1. Create text with various relationships:
   - "RISK-001 mitigated by CTRL-042"
   - "CTRL-042 maps to POLICY-03"
   - "POLICY-03 implements STANDARD-ISO27001"
   - "FINDING-05 addresses RISK-002"
2. Call detect_entity_relationships()
3. Verify all 4 relationship triples detected

**Expected Results**:
- 4 triples returned:
  - (RISK-001, mitigated_by, CTRL-042)
  - (CTRL-042, maps_to, POLICY-03)
  - (POLICY-03, implements, STANDARD-ISO27001)
  - (FINDING-05, addresses, RISK-002)
- Relationship keywords normalized (consistent format)

---

#### Test Case TC-3.2-3-3

**Acceptance Criterion**: AC-3.2-3
**Test Type**: Edge Case - Long-Distance Relationship

**Objective**: Verify handling of relationships spanning >chunk_size (entities in different chunks)

**Preconditions**:
- RISK-001 at position 100, CTRL-042 at position 2000 (span > chunk_size=512)

**Test Steps**:
1. Create document with distant relationship (span=1900 chars)
2. Call chunk_document()
3. Verify entities in separate chunks (unavoidable)
4. Verify both chunks include relationship metadata with cross-references
5. Verify relationship triple stored in both chunks' metadata

**Expected Results**:
- Entities in separate chunks (Chunk N and Chunk M)
- Both chunks include relationship triple in metadata
- Metadata includes cross-chunk reference (chunk_id of related entity)
- Relationship reconstructable via cross-references

---

#### Test Case TC-3.2-3-4

**Acceptance Criterion**: AC-3.2-3
**Test Type**: Integration
**Scenario**: Integration - Relationship-Rich Document

**Objective**: End-to-end validation with SOC2 compliance document (100+ relationships)

**Preconditions**:
- Fixture: `tests/fixtures/entity_rich_documents/soc2_compliance_mapping.md`
- Document contains 100+ control-requirement relationships

**Test Steps**:
1. Load SOC2 compliance document (normalized)
2. Run chunk_document()
3. Count total relationships detected
4. Calculate preservation rate (relationships within single chunks vs split)
5. Verify >80% of relationships preserved within chunks

**Expected Results**:
- >80% of relationships in single chunks
- Relationship triples populated in metadata
- Split relationships include cross-references
- Realistic document validates production readiness

**Dependencies**:
- Fixtures: `tests/fixtures/entity_rich_documents/soc2_compliance_mapping.md`

---

#### Test Case TC-3.2-3-5

**Acceptance Criterion**: AC-3.2-3
**Test Type**: Error Case - Malformed Relationship Pattern

**Objective**: Verify graceful handling of ambiguous relationship text

**Preconditions**:
- Text: "RISK-001 and CTRL-042 are related somehow"

**Test Steps**:
1. Create text with vague relationship (no clear keyword)
2. Call detect_entity_relationships()
3. Verify no false positive relationships detected
4. Verify both entities still tagged in metadata (even without relationship)

**Expected Results**:
- No relationship triple generated (ambiguous pattern)
- Both entities appear in ChunkMetadata.entity_tags
- No crash or incorrect relationship inferred
- Graceful degradation (skip relationship detection, preserve entities)

---

### AC-3.2-4: Chunk Boundaries Avoid Splitting Entity Definitions

#### Test Case TC-3.2-4-1

**Acceptance Criterion**: AC-3.2-4
**Test Type**: Unit
**Scenario**: Happy Path

**Objective**: Verify multi-sentence entity definitions remain intact

**Preconditions**:
- Entity definition spans 3 sentences (200 tokens total)

**Test Steps**:
1. Create text with multi-sentence entity:
   ```
   RISK-001: Data breach risk. This risk arises from inadequate access controls.
   The potential impact includes regulatory fines and reputational damage.
   ```
2. Call chunk_document(chunk_size=512)
3. Verify all 3 sentences appear in same chunk
4. Verify chunk boundary placed AFTER entity definition completes

**Expected Results**:
- Entity definition intact (all 3 sentences in one chunk)
- Next chunk starts after entity definition ends
- EntityReference spans all 3 sentences (start_pos to end_pos)

**Test Data**:
- Input: Multi-sentence entity definition (3 sentences, 200 tokens)
- Expected Output: Single chunk containing complete definition

---

#### Test Case TC-3.2-4-2

**Acceptance Criterion**: AC-3.2-4
**Test Type**: Edge Case - Entity Definition > chunk_size

**Objective**: Verify very long entity definition becomes single oversized chunk

**Preconditions**:
- Entity definition = 800 tokens, chunk_size=512

**Test Steps**:
1. Create 800-token entity definition (10 sentences)
2. Call chunk_document(chunk_size=512)
3. Verify entire definition becomes single chunk (size=800, exceeds target)
4. Verify warning logged
5. Verify next chunk starts after definition ends

**Expected Results**:
- Single oversized chunk (800 tokens)
- Warning: "Entity definition exceeds chunk_size, creating oversized chunk"
- Definition not split (preserves complete context)
- Next chunk starts cleanly after definition

---

#### Test Case TC-3.2-4-3

**Acceptance Criterion**: AC-3.2-4
**Test Type**: Edge Case - Adjacent Entity Definitions

**Objective**: Verify boundary placement between consecutive entity definitions

**Preconditions**:
- Two entities with definitions: Entity A (200 tokens), Entity B (200 tokens), gap=50 tokens

**Test Steps**:
1. Create text with adjacent entity definitions separated by 50 tokens
2. Call chunk_document(chunk_size=512)
3. Verify chunk boundary placed in gap (not within either definition)
4. Verify both definitions intact (each in separate chunk or both in one chunk)

**Expected Results**:
- Chunk boundary in 50-token gap between entities
- Neither entity definition split
- EntityPreserver.find_entity_gaps() identifies 50-token gap
- Boundary placed at gap (optimal split point)

---

#### Test Case TC-3.2-4-4

**Acceptance Criterion**: AC-3.2-4
**Test Type**: Integration
**Scenario**: Integration - Policy Document with Definitions

**Objective**: End-to-end validation with policy document containing 20+ multi-sentence definitions

**Preconditions**:
- Fixture: `tests/fixtures/entity_rich_documents/policy_definitions.md`
- 20+ policy entities, each with 2-5 sentence definitions

**Test Steps**:
1. Load policy document (normalized)
2. Run chunk_document()
3. Verify all entity definitions intact (not split mid-definition)
4. Calculate definition preservation rate (should be 100%)

**Expected Results**:
- 100% of entity definitions preserved intact
- Chunk boundaries after definitions complete
- No mid-definition splits
- Realistic document validates production readiness

**Dependencies**:
- Fixtures: `tests/fixtures/entity_rich_documents/policy_definitions.md`

---

#### Test Case TC-3.2-4-5

**Acceptance Criterion**: AC-3.2-4
**Test Type**: Error Case - Ambiguous Entity Definition Boundary

**Objective**: Verify handling when entity definition end is unclear

**Preconditions**:
- Entity description without clear termination marker

**Test Steps**:
1. Create text: "RISK-001 involves data breach which could lead to issues..."
2. Call analyze_entities() (Epic 2 provides end_pos)
3. Verify EntityPreserver uses Epic 2 entity boundaries (start_pos, end_pos)
4. Verify chunk boundary respects Epic 2 boundaries

**Expected Results**:
- EntityPreserver relies on Epic 2 entity positions (not re-parsing)
- Chunk boundary placed after end_pos from Epic 2
- No ambiguity (Epic 2 normalization defines boundaries)
- Graceful handling (no entity re-detection)

---

### AC-3.2-5: Cross-References Maintained with Entity IDs

#### Test Case TC-3.2-5-1

**Acceptance Criterion**: AC-3.2-5
**Test Type**: Unit
**Scenario**: Happy Path

**Objective**: Verify entity IDs propagated from Epic 2 to ChunkMetadata

**Preconditions**:
- ProcessingResult with entities: RISK-001, CTRL-042, POLICY-03

**Test Steps**:
1. Create ProcessingResult with 3 entities (entity_id populated from Epic 2)
2. Call chunk_document()
3. For each chunk, verify ChunkMetadata.entity_tags includes entity_id
4. Verify entity_id matches Epic 2 entity.entity_id

**Expected Results**:
- All EntityReference objects include entity_id
- entity_id values match Epic 2 source
- Cross-chunk entity search enabled (find all chunks with entity_id="RISK-001")

**Test Data**:
- Input: 3 entities with IDs RISK-001, CTRL-042, POLICY-03
- Expected Output: ChunkMetadata.entity_tags[0].entity_id = "RISK-001"

---

#### Test Case TC-3.2-5-2

**Acceptance Criterion**: AC-3.2-5
**Test Type**: Edge Case - Duplicate Entity Mentions

**Objective**: Verify duplicate entity mentions within same chunk deduplicated

**Preconditions**:
- Chunk contains "RISK-001" mentioned 3 times

**Test Steps**:
1. Create text with repeated entity: "RISK-001 is critical. RISK-001 impacts... RISK-001 requires..."
2. Call chunk_document()
3. Verify ChunkMetadata.entity_tags includes RISK-001 once (not 3 times)
4. Verify deduplication based on entity_id

**Expected Results**:
- ChunkMetadata.entity_tags contains 1 entry for RISK-001 (deduplicated)
- EntityReference.start_pos and end_pos reflect first mention
- Multiple mentions don't inflate metadata

---

#### Test Case TC-3.2-5-3

**Acceptance Criterion**: AC-3.2-5
**Test Type**: Integration
**Scenario**: Integration - Cross-Chunk Entity Search

**Objective**: Validate finding all chunks mentioning specific entity_id

**Preconditions**:
- Document with RISK-001 mentioned in 5 different chunks

**Test Steps**:
1. Generate chunks from document with repeated entity
2. Implement helper: find_chunks_by_entity_id(entity_id, chunks)
3. Call find_chunks_by_entity_id("RISK-001", chunks)
4. Verify 5 chunks returned

**Expected Results**:
- Helper returns 5 chunks containing RISK-001
- Entity ID enables efficient cross-chunk lookup
- Supports RAG use case (find all context for entity)

**Dependencies**:
- Helpers: `find_chunks_by_entity_id(entity_id, chunks)`

---

### AC-3.2-6: Entity Tags in Chunk Metadata

#### Test Case TC-3.2-6-1

**Acceptance Criterion**: AC-3.2-6
**Test Type**: Unit
**Scenario**: Happy Path

**Objective**: Verify EntityReference objects populated correctly in ChunkMetadata

**Preconditions**:
- Chunk contains 3 entities: RISK-001, CTRL-042, POLICY-03

**Test Steps**:
1. Generate chunk with 3 entities
2. Verify ChunkMetadata.entity_tags is List[EntityReference]
3. Verify each EntityReference has all required fields:
   - entity_type (str)
   - entity_id (str)
   - start_pos (int)
   - end_pos (int)
   - is_partial (bool)
   - context_snippet (str)
4. Verify all values populated correctly

**Expected Results**:
- entity_tags contains 3 EntityReference objects
- All fields populated with correct types
- context_snippet includes ±20 chars around entity
- is_partial=False for intact entities

**Test Data**:
- Input: Chunk with 3 entities
- Expected Output: entity_tags=[EntityReference(...), EntityReference(...), EntityReference(...)]

---

#### Test Case TC-3.2-6-2

**Acceptance Criterion**: AC-3.2-6
**Test Type**: Unit
**Scenario**: Edge Case - Empty Entity List

**Objective**: Verify entity_tags is empty list (not null) when no entities

**Preconditions**:
- Chunk with no entities

**Test Steps**:
1. Generate chunk from plain text (no entities)
2. Verify ChunkMetadata.entity_tags == []
3. Verify entity_tags is not None (empty list, not null)

**Expected Results**:
- entity_tags = [] (empty list)
- Not null/None
- Serializes to JSON as []

---

#### Test Case TC-3.2-6-3

**Acceptance Criterion**: AC-3.2-6
**Test Type**: Unit
**Scenario**: Edge Case - JSON Serialization

**Objective**: Verify EntityReference objects serialize to JSON correctly

**Preconditions**:
- Chunk with 2 entities

**Test Steps**:
1. Generate chunk with 2 entities
2. Call Chunk.to_dict()
3. Verify entity_tags serializes to list of dicts
4. Verify JSON schema valid (all fields present)
5. Verify nested EntityReference objects converted to dicts

**Expected Results**:
- to_dict() returns dict with entity_tags as list of dicts
- Each EntityReference becomes {"entity_type": "...", "entity_id": "...", ...}
- JSON serializable (no Pydantic objects in output)
- Schema validation passes

---

#### Test Case TC-3.2-6-4

**Acceptance Criterion**: AC-3.2-6
**Test Type**: Error Case - Invalid EntityReference

**Objective**: Verify Pydantic validation catches invalid EntityReference data

**Preconditions**:
- Attempt to create EntityReference with missing required field

**Test Steps**:
1. Attempt to create EntityReference without entity_id field
2. Verify Pydantic ValidationError raised
3. Verify error message indicates missing field

**Expected Results**:
- ValidationError raised
- Error message: "Field required: entity_id"
- Invalid metadata rejected (cannot create corrupt chunks)

---

### AC-3.2-7: Section Boundaries Respected (Deferred AC-3.1-2)

#### Test Case TC-3.2-7-1

**Acceptance Criterion**: AC-3.2-7
**Test Type**: Integration
**Scenario**: Happy Path

**Objective**: Verify chunks align with section boundaries in multi-section document

**Preconditions**:
- ProcessingResult with ContentBlocks including type="heading"
- Document has 5 sections with headings

**Test Steps**:
1. Create ProcessingResult with 5 ContentBlock headings ("Risk Assessment", "Control Catalog", etc.)
2. Call ChunkingEngine._detect_section_boundaries()
3. Verify 5 section boundaries detected
4. Call chunk_document()
5. Verify chunks align with section starts/ends (where chunk_size permits)
6. Verify ChunkMetadata.section_context populated ("Risk Assessment > High Severity Risks")

**Expected Results**:
- 5 sections detected correctly
- Chunk boundaries align with section boundaries
- section_context populated as breadcrumb trail ("Parent > Child")
- No mid-section splits (unless section > chunk_size)

**Test Data**:
- Input: Multi-section document with 5 headings
- Expected Output: Chunks with section_context populated

**Dependencies**:
- Fixtures: `tests/fixtures/entity_rich_documents/multi_section_policy.md`

---

#### Test Case TC-3.2-7-2

**Acceptance Criterion**: AC-3.2-7
**Test Type**: Unit
**Scenario**: Edge Case - Section Detection via Regex Patterns

**Objective**: Verify section detection using structural patterns (### Title, 1.2.3 Heading)

**Preconditions**:
- Text with markdown headings and numbered sections

**Test Steps**:
1. Create text with patterns:
   ```
   ### Risk Assessment
   Some content...

   1.2.3 Identified Risks
   More content...
   ```
2. Call _detect_section_boundaries()
3. Verify both patterns detected (markdown ### and numbered 1.2.3)
4. Verify section positions mapped to sentence indices

**Expected Results**:
- 2 section boundaries detected
- Regex patterns match both ### and 1.2.3 formats
- Section positions correct (mapped to sentence start indices)

---

#### Test Case TC-3.2-7-3

**Acceptance Criterion**: AC-3.2-7
**Test Type**: Edge Case - Section Hierarchy (Parent-Child)

**Objective**: Verify nested section hierarchy reflected in breadcrumb context

**Preconditions**:
- Document with nested sections: "Risk Assessment" > "High Severity" > "Critical Risks"

**Test Steps**:
1. Create document with 3-level section hierarchy
2. Call _detect_section_boundaries()
3. Verify section hierarchy built correctly (parent-child relationships)
4. Generate chunks within nested section
5. Verify ChunkMetadata.section_context = "Risk Assessment > High Severity > Critical Risks"

**Expected Results**:
- Section hierarchy detected (3 levels)
- section_context breadcrumb includes all levels (Parent > Child > Grandchild)
- Delimiter ` > ` consistent

---

#### Test Case TC-3.2-7-4

**Acceptance Criterion**: AC-3.2-7
**Test Type**: Edge Case - Large Section Exceeding chunk_size

**Objective**: Verify large section split at sentence boundaries (maintains AC-3.1-1)

**Preconditions**:
- Section with 2000 tokens (chunk_size=512)

**Test Steps**:
1. Create large section (2000 tokens, 50 sentences)
2. Call chunk_document(chunk_size=512)
3. Verify section split into multiple chunks (4 chunks)
4. Verify splits at sentence boundaries (not mid-sentence)
5. Verify all chunks have same section_context (same section)

**Expected Results**:
- Section split into 4 chunks (512 tokens each)
- Splits at sentence boundaries (AC-3.1-1 maintained)
- All 4 chunks have section_context = "Large Section Name"
- No mid-sentence splits

---

#### Test Case TC-3.2-7-5

**Acceptance Criterion**: AC-3.2-7
**Test Type**: Edge Case - No Sections Detected (Graceful Fallback)

**Objective**: Verify graceful degradation when no section markers detected

**Preconditions**:
- Plain text document with no headings, no page breaks, no structural patterns

**Test Steps**:
1. Create plain text document (no section markers)
2. Call _detect_section_boundaries()
3. Verify empty list returned (no sections)
4. Call chunk_document()
5. Verify chunking falls back to sentence-boundary-only splitting (Story 3.1)
6. Verify ChunkMetadata.section_context = "" (empty string)

**Expected Results**:
- _detect_section_boundaries() returns []
- No sections detected (expected for plain text)
- Chunking works correctly (fallback to Story 3.1 behavior)
- section_context = "" for all chunks
- No errors or warnings

---

#### Test Case TC-3.2-7-6

**Acceptance Criterion**: AC-3.2-7
**Test Type**: Integration
**Scenario**: Integration - SOC2 Report with Page Breaks

**Objective**: Validate section detection using page break markers from PDF extraction

**Preconditions**:
- ProcessingResult from PDF with page break markers in source_metadata

**Test Steps**:
1. Load ProcessingResult with page_break markers (from Epic 2 PDF extraction)
2. Call _detect_section_boundaries()
3. Verify page breaks detected as section boundaries
4. Verify chunks align with page boundaries where possible

**Expected Results**:
- Page breaks detected as section boundaries
- Chunks align with page breaks (where chunk_size permits)
- section_context includes page numbers or section names from PDF
- Integration with Epic 2 PDF metadata successful

**Dependencies**:
- Fixtures: ProcessingResult from PDF with page breaks

---

### AC-3.2-8: Determinism Maintained

#### Test Case TC-3.2-8-1

**Acceptance Criterion**: AC-3.2-8
**Test Type**: Integration
**Scenario**: Happy Path

**Objective**: Verify entity-aware chunking produces identical output across 10 runs

**Preconditions**:
- Entity-rich ProcessingResult (50+ entities)

**Test Steps**:
1. Load ProcessingResult with entities
2. Run ChunkingEngine.chunk_document() 10 times
3. For each run, serialize chunks to JSON
4. Compare all 10 outputs byte-for-byte
5. Verify all outputs identical (no differences)

**Expected Results**:
- All 10 runs produce identical output (byte-for-byte)
- No randomness in entity analysis or chunk generation
- Determinism maintained (AC-3.2-8 satisfied)

**Test Data**:
- Input: Entity-rich document (50+ entities)
- Expected Output: 10 identical JSON outputs (diff = 0 differences)

**Dependencies**:
- Helpers: `serialize_chunks_to_json(chunks)`

---

#### Test Case TC-3.2-8-2

**Acceptance Criterion**: AC-3.2-8
**Test Type**: Unit
**Scenario**: Edge Case - Entity Analysis Order

**Objective**: Verify entities analyzed in consistent order (sorted by start_pos)

**Preconditions**:
- Entities with positions: Entity A (pos=500), Entity B (pos=100), Entity C (pos=300)

**Test Steps**:
1. Create ProcessingResult with entities in random order (A, B, C)
2. Call EntityPreserver.analyze_entities()
3. Verify entities processed in sorted order (B, C, A by start_pos)
4. Verify EntityReference list sorted by start_pos
5. Run 5 times, verify same order each time

**Expected Results**:
- Entities sorted by start_pos before processing (B=100, C=300, A=500)
- EntityReference list always in same order
- Deterministic entity analysis (no randomness)

---

#### Test Case TC-3.2-8-3

**Acceptance Criterion**: AC-3.2-8
**Test Type**: Integration
**Scenario**: Integration - Section Detection Determinism

**Objective**: Verify section detection produces consistent results

**Preconditions**:
- Multi-section document

**Test Steps**:
1. Load multi-section document
2. Run _detect_section_boundaries() 10 times
3. Verify same sections detected each run (same positions)
4. Verify section hierarchy same each run

**Expected Results**:
- All 10 runs detect same sections (same positions)
- Section hierarchy consistent
- No random ordering in regex pattern matching

---

## Testing Notes

### Execution Recommendations

**Critical Tests (Must Pass - Blockers)**:
- TC-3.2-1-1 (Entity preservation rate >95%)
- TC-3.2-3-1 (Relationship preservation)
- TC-3.2-7-1 (Section boundary alignment)
- TC-3.2-8-1 (Determinism validation)

**Suggested Execution Order**:
1. **Unit tests first** (fast feedback):
   - EntityPreserver tests (TC-3.2-1-2, TC-3.2-1-3, TC-3.2-4-1)
   - Section detection tests (TC-3.2-7-2, TC-3.2-7-3)
   - Metadata tests (TC-3.2-6-1, TC-3.2-6-2)
2. **Integration tests** (end-to-end validation):
   - Entity preservation (TC-3.2-1-1, TC-3.2-1-7)
   - Relationship preservation (TC-3.2-3-1, TC-3.2-3-4)
   - Section boundaries (TC-3.2-7-1, TC-3.2-7-6)
3. **Determinism tests** (final validation):
   - TC-3.2-8-1, TC-3.2-8-2, TC-3.2-8-3
4. **Performance tests** (NFR validation):
   - Entity overhead <0.3s per 10k words
   - Total latency <3.3s per 10k words

**Tests That Can Run in Parallel**:
- All unit tests (no dependencies)
- Integration tests with different fixtures (isolated)
- Performance tests (separate baseline runs)

**Estimated Test Execution Time**:
- Unit tests: ~45 seconds (23 tests, fast)
- Integration tests: ~3 minutes (12 tests, slower with fixtures)
- Performance tests: ~2 minutes (baseline runs)
- Manual tests: ~10 minutes (human execution)
- **Total: ~16 minutes**

### Implementation Notes

**Pytest Markers to Use**:
```python
@pytest.mark.unit
@pytest.mark.integration
@pytest.mark.performance
@pytest.mark.chunking
@pytest.mark.entity_aware  # NEW marker for Story 3.2
```

**Fixture Requirements**:

**Required New Fixtures**:
1. `tests/fixtures/entity_rich_documents/risk_register_sample.md` - 50+ entities (risks, controls)
2. `tests/fixtures/entity_rich_documents/anonymized_risk_register.md` - 100+ entities (real-world)
3. `tests/fixtures/entity_rich_documents/soc2_compliance_mapping.md` - 100+ relationships
4. `tests/fixtures/entity_rich_documents/policy_definitions.md` - 20+ multi-sentence definitions
5. `tests/fixtures/entity_rich_documents/multi_section_policy.md` - Multi-section document with headings

**Fixture Size Limit**: Total <100MB (keep entity-rich documents <20MB each)

**Helper Functions Needed**:
1. `calculate_entity_preservation_rate(chunks, entities) -> float`
2. `find_all_chunks_for_entity(entity_id, chunks) -> List[Chunk]`
3. `validate_entity_cross_references(chunks) -> ValidationResult`
4. `find_chunks_by_entity_id(entity_id, chunks) -> List[Chunk]`
5. `generate_preservation_report(chunks, entities) -> Report`
6. `serialize_chunks_to_json(chunks) -> str`

**Integration Points to Mock/Stub**:
- None required (Epic 2 integration tested via real ProcessingResult fixtures)
- spaCy model loading (already cached globally from Story 3.1)

### Risk Areas

**Complex Scenarios Requiring Extra Attention**:

1. **Entity Overlap Handling (TC-3.2-1-5)**:
   - Risk: Overlapping entity spans could cause incorrect metadata or crashes
   - Mitigation: Defensive programming, explicit overlap tests

2. **Very Large Entities (TC-3.2-1-4, TC-3.2-4-2)**:
   - Risk: Entities >chunk_size create oversized chunks, could break downstream assumptions
   - Mitigation: Clear warnings logged, metadata flags oversized chunks

3. **Multi-Chunk Entity Chains (TC-3.2-2-3)**:
   - Risk: Cross-reference chains >2 chunks could have broken links
   - Mitigation: Validation helper to check chain integrity

4. **Section Detection Fallback (TC-3.2-7-5)**:
   - Risk: No sections detected could cause silent failures
   - Mitigation: Graceful degradation to Story 3.1 behavior, empty section_context (not null)

**Potential Failure Points**:

1. **Entity Preservation Rate <95%**:
   - Symptom: TC-3.2-1-1 fails, rate=88%
   - Root Cause: EntityPreserver.find_entity_gaps() misses optimal split points
   - Remediation: Adjust gap detection logic, widen search window (±20% → ±30%)

2. **Determinism Failures**:
   - Symptom: TC-3.2-8-1 shows differences in runs 3 vs 7
   - Root Cause: Non-deterministic entity ordering or tiebreaking
   - Remediation: Verify entities sorted by start_pos, use deterministic tiebreaker (prefer earlier position)

3. **Section Hierarchy Incorrect**:
   - Symptom: TC-3.2-7-3 shows flat hierarchy instead of nested
   - Root Cause: Section parent-child relationship logic incorrect
   - Remediation: Review _detect_section_boundaries() hierarchy building logic

**Performance Bottlenecks**:

1. **Entity Analysis Overhead**:
   - Risk: analyze_entities() takes >0.3s per 10k words (exceeds budget)
   - Mitigation: Profile entity gap finding, optimize if needed (cache gaps?)

2. **Section Detection Overhead**:
   - Risk: Regex matching on large documents takes >0.1s
   - Mitigation: Limit regex search to ContentBlocks (not full text), cache results

**Security Considerations**:

1. **Entity Injection via Malicious Text**:
   - Risk: Crafted text with 10,000 fake entities overwhelms metadata
   - Mitigation: Epic 2 normalization limits entities (unlikely), metadata size warnings

2. **Regex DoS (ReDoS)**:
   - Risk: Malicious section patterns cause catastrophic backtracking in regex
   - Mitigation: Use simple, bounded regex patterns (avoid nested quantifiers)

---

## Acceptance Criteria Coverage

**AC-3.2-1: Entity Mentions Kept Within Single Chunks (>95%)**
- ✓ TC-3.2-1-1 (Happy Path - Integration)
- ✓ TC-3.2-1-2 (Edge Case - Very Small Chunks)
- ✓ TC-3.2-1-3 (Edge Case - Dense Entity Clusters)
- ✓ TC-3.2-1-4 (Edge Case - Very Large Single Entity)
- ✓ TC-3.2-1-5 (Error Case - Overlapping Entities)
- ✓ TC-3.2-1-6 (Error Case - Empty Entity List)
- ✓ TC-3.2-1-7 (Integration - Real-World Risk Register)

**AC-3.2-2: Entities Split Across Chunks Noted in Metadata**
- ✓ TC-3.2-2-1 (Happy Path)
- ✓ TC-3.2-2-2 (Edge Case - Multiple Partial Entities)
- ✓ TC-3.2-2-3 (Edge Case - Entity Spans Three Chunks)
- ✓ TC-3.2-2-4 (Integration - Partial Entity Search)
- ✓ TC-3.2-2-5 (Error Case - Missing Cross-Reference)

**AC-3.2-3: Relationship Context Preserved**
- ✓ TC-3.2-3-1 (Happy Path - Integration)
- ✓ TC-3.2-3-2 (Edge Case - Multiple Relationship Types)
- ✓ TC-3.2-3-3 (Edge Case - Long-Distance Relationship)
- ✓ TC-3.2-3-4 (Integration - Relationship-Rich Document)
- ✓ TC-3.2-3-5 (Error Case - Malformed Relationship Pattern)

**AC-3.2-4: Chunk Boundaries Avoid Splitting Entity Definitions**
- ✓ TC-3.2-4-1 (Happy Path)
- ✓ TC-3.2-4-2 (Edge Case - Entity Definition > chunk_size)
- ✓ TC-3.2-4-3 (Edge Case - Adjacent Entity Definitions)
- ✓ TC-3.2-4-4 (Integration - Policy Document with Definitions)
- ✓ TC-3.2-4-5 (Error Case - Ambiguous Entity Definition Boundary)

**AC-3.2-5: Cross-References Maintained with Entity IDs**
- ✓ TC-3.2-5-1 (Happy Path)
- ✓ TC-3.2-5-2 (Edge Case - Duplicate Entity Mentions)
- ✓ TC-3.2-5-3 (Integration - Cross-Chunk Entity Search)

**AC-3.2-6: Entity Tags in Chunk Metadata**
- ✓ TC-3.2-6-1 (Happy Path)
- ✓ TC-3.2-6-2 (Edge Case - Empty Entity List)
- ✓ TC-3.2-6-3 (Edge Case - JSON Serialization)
- ✓ TC-3.2-6-4 (Error Case - Invalid EntityReference)

**AC-3.2-7: Section Boundaries Respected (Deferred AC-3.1-2)**
- ✓ TC-3.2-7-1 (Happy Path - Integration)
- ✓ TC-3.2-7-2 (Edge Case - Section Detection via Regex)
- ✓ TC-3.2-7-3 (Edge Case - Section Hierarchy)
- ✓ TC-3.2-7-4 (Edge Case - Large Section Exceeding chunk_size)
- ✓ TC-3.2-7-5 (Edge Case - No Sections Detected)
- ✓ TC-3.2-7-6 (Integration - SOC2 Report with Page Breaks)

**AC-3.2-8: Determinism Maintained**
- ✓ TC-3.2-8-1 (Happy Path - Integration)
- ✓ TC-3.2-8-2 (Edge Case - Entity Analysis Order)
- ✓ TC-3.2-8-3 (Integration - Section Detection Determinism)

**Coverage Summary**:
- All 8 acceptance criteria covered
- 40 test cases total (standard coverage level)
- Critical ACs (P0) have 5-7 tests each
- Non-critical ACs (P1) have 3-4 tests each
- Happy paths, edge cases, error cases, and integration scenarios included

---

## Next Steps

1. **Review test cases**: Validate coverage and scenarios
2. **Run build-test-context**: Gather fixtures and helpers → `workflow build-test-context`
3. **Implement missing fixtures**: Create entity-rich document fixtures
4. **Execute tests**: Run via execute-tests workflow → `workflow execute-tests`
5. **Review results**: QA review via review-uat-results workflow → `workflow review-uat-results`

---

**Document Status**: Ready for Context Building
**Generated by**: andrew using BMAD UAT Framework
