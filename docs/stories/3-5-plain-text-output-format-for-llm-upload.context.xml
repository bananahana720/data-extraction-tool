<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.5</storyId>
    <title>Plain Text Output Format for LLM Upload</title>
    <status>drafted</status>
    <generatedAt>2025-11-15T06:30:00Z</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/3-5-plain-text-output-format-for-llm-upload.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>power user generating audit context for LLM workflows</asA>
    <iWant>clean plain text output optimized for direct ChatGPT/Claude upload</iWant>
    <soThat>I can copy/paste predictable, metadata-rich chunks without manual cleanup</soThat>
    <tasks>
      - Task 1: Implement TxtFormatter core (AC: 1,2,3,5)
        * Create src/data_extract/output/formatters/txt_formatter.py implementing BaseFormatter
        * Support clean text rendering + delimiter + optional metadata header w/ config cascade
        * Ensure encoding uses utf-8-sig and document newline behavior

      - Task 2: Wire formatter into orchestrator + CLI (AC: 4,5)
        * Register TxtFormatter in output/writer.py / CLI flags alongside JSON/CSV
        * Respect organization strategies (by_document, by_entity, flat) and concatenated/per-chunk options

      - Task 3: Testing &amp; fixtures (AC: 1-6)
        * Add unit tests tests/unit/test_output/test_txt_formatter.py covering delimiter, headers, encoding
        * Extend integration tests to verify organization + metadata interplay (reuse story 3.4 fixtures, fix utf-8-sig reads per action item)
        * Add manual/UAT checklist script for ChatGPT/Claude paste validation

      - Task 4: Documentation &amp; QA (AC: 5-7)
        * Update docs/json-schema-reference.md + CLAUDE.md with TXT usage guidance
        * Produce sample outputs in docs/examples/ for copy/paste workflows
        * Close outstanding Story 3.4 action item (integration encoding fix) to unblock UAT evidence
    </tasks>
  </story>

  <acceptanceCriteria>
    AC-3.5-1: Clean chunk text (P0)
      - TXT output strips markdown/HTML artifacts, preserves intentional paragraph spacing
      - Guarantees deterministic whitespace across platforms
      - Source: docs/tech-spec-epic-3.md:1159-1167
      - UAT Required: Yes - Manual review sample

    AC-3.5-2: Configurable delimiters (P0)
      - Default delimiter: ━━━ CHUNK {{n}} ━━━
      - Configurable via CLI/config
      - Delimiter always appears between chunks in concatenated mode
      - Source: docs/epics.md:435-443
      - UAT Required: No - Unit test sufficient

    AC-3.5-3: Optional metadata header (P1)
      - When --include-metadata is set, each chunk emits compact header
      - Header includes: source file, chunk id, entity tags, quality score
      - Header precedes text block
      - Source: docs/tech-spec-epic-3.md:1159-1167
      - UAT Required: Yes - Format validation

    AC-3.5-4: Output organization (P0)
      - Formatter supports concatenated single-file exports
      - Formatter supports individual per-chunk files
      - Honors global organization strategies (by_document, by_entity, flat)
      - Source: docs/epics.md:439-443
      - UAT Required: Yes

    AC-3.5-5: UTF-8 encoding (P0)
      - TXT files written with UTF-8 (utf-8-sig for Windows compatibility)
      - Documented newline handling (LF default, CRLF optional)
      - Source: docs/tech-spec-epic-3.md:1163-1164
      - UAT Required: No - Encoding test

    AC-3.5-6: No formatting artifacts (P1)
      - Formatter removes BOM duplication, stray JSON braces, CLI color codes
      - QA verifies zipped sample has zero lint-detected anomalies
      - Source: docs/PRD.md:772-779
      - UAT Required: Yes - Manual review

    AC-3.5-7: LLM upload readiness (P0 - Critical)
      - Manual UAT demonstrates copy/paste into ChatGPT and Claude prompts
      - No additional cleanup required
      - References at least one real chunk from integration fixtures
      - Source: docs/tech-spec-epic-3.md:1159-1167
      - UAT Required: Yes - Critical
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification - Epic 3</title>
        <section>Story 3.5: Plain Text Output Format for LLM Upload (lines 1153-1167)</section>
        <snippet>AC-3.5-1 through AC-3.5-7 define the seven gating behaviors: clean text, delimiter control, optional headers, organization modes, UTF-8, artifact-free formatting, and copy/paste readiness. UAT Focus: LLM upload readiness (manual test with ChatGPT/Claude), formatting cleanliness.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR-3.3: Multiple Output Formats (lines 772-781)</section>
        <snippet>TXT: Clean plain text, one chunk per file or concatenated. Acceptance Criteria ensure no formatting artifacts (BOM duplication, stray JSON braces, CLI color codes) and QA verification via zipped sample with zero lint-detected anomalies.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Output Pipeline (lines 113-119)</section>
        <snippet>TxtFormatter will live beside JsonFormatter under src/data_extract/output/formatters/, plugged into output/writer.py so CLI invocations (data-extract process --format txt) follow the same BaseFormatter contract.</snippet>
      </doc>
      <doc>
        <path>docs/json-schema-reference.md</path>
        <title>JSON Schema Reference</title>
        <section>Overview (lines 0-10)</section>
        <snippet>Reference document for JsonFormatter output structure. Story 3.5 will need parallel documentation for TxtFormatter showing delimiter patterns, metadata headers, and organization strategies.</snippet>
      </doc>
      <doc>
        <path>docs/stories/3-4-json-output-format-with-full-metadata.md</path>
        <title>Story 3.4: JSON Output Format with Full Metadata</title>
        <section>Context Summary &amp; Implementation Patterns (lines 0-200)</section>
        <snippet>Story 3.4 hardened ChunkMetadata (source_file + config_snapshot), BOM handling (utf-8-sig), and fail-fast validation. TxtFormatter must reuse those canonical inputs. Outstanding action items: integration-test encoding fixes and quality gates from Story 3.4 remain, so Story 3.5 has to close the utf-8-sig coverage gap alongside new TXT validation.</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>src/data_extract/output/formatters/base.py</path>
        <kind>protocol</kind>
        <symbol>BaseFormatter</symbol>
        <lines>52-91</lines>
        <reason>Protocol that all formatters (JSON, TXT, CSV) must implement. TxtFormatter will implement format_chunks() method following this contract.</reason>
      </artifact>
      <artifact>
        <path>src/data_extract/output/formatters/base.py</path>
        <kind>dataclass</kind>
        <symbol>FormatResult</symbol>
        <lines>16-50</lines>
        <reason>Immutable result returned by all formatters. TxtFormatter.format_chunks() must return FormatResult with format_type="txt".</reason>
      </artifact>
      <artifact>
        <path>src/data_extract/output/formatters/json_formatter.py</path>
        <kind>class</kind>
        <symbol>JsonFormatter</symbol>
        <lines>25-340</lines>
        <reason>Reference implementation for formatters. TxtFormatter should follow similar patterns: __init__ with config, format_chunks() implementation, helper methods for serialization, BOM handling via utf-8-sig encoding.</reason>
      </artifact>
      <artifact>
        <path>src/data_extract/chunk/models.py</path>
        <kind>dataclass</kind>
        <symbol>ChunkMetadata</symbol>
        <lines>21-130</lines>
        <reason>Metadata attached to each chunk. TxtFormatter will extract fields for optional metadata headers: source_file, section_context, entity_tags, quality scores, processing_version.</reason>
      </artifact>
      <artifact>
        <path>src/data_extract/core/models.py</path>
        <kind>dataclass</kind>
        <symbol>Chunk</symbol>
        <lines>full-file</lines>
        <reason>Core chunk model re-exported from chunk/models.py. Contains text, metadata, entities, quality fields that TxtFormatter must serialize.</reason>
      </artifact>
      <artifact>
        <path>src/data_extract/chunk/entity_preserver.py</path>
        <kind>dataclass</kind>
        <symbol>EntityReference</symbol>
        <lines>full-file</lines>
        <reason>Entity reference model for entity-aware chunking. TxtFormatter may include entity IDs in metadata headers when --include-metadata flag is enabled.</reason>
      </artifact>
      <artifact>
        <path>src/data_extract/chunk/quality.py</path>
        <kind>dataclass</kind>
        <symbol>QualityScore</symbol>
        <lines>full-file</lines>
        <reason>Quality scoring model from Story 3.3. TxtFormatter may include overall quality score in metadata headers for filtering/prioritization.</reason>
      </artifact>
    </code>

    <dependencies>
      <python>
        <package name="pathlib" version="stdlib">Path manipulation for output file organization</package>
        <package name="typing" version="stdlib">Type hints for BaseFormatter protocol implementation</package>
        <package name="dataclasses" version="stdlib">FormatResult immutable result dataclass</package>
        <package name="time" version="stdlib">Duration tracking for FormatResult.duration_seconds</package>
        <package name="re" version="stdlib">Potential artifact removal (stray JSON braces, CLI color codes)</package>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    - Follow BaseFormatter protocol exactly (src/data_extract/output/formatters/base.py)
    - Return FormatResult with format_type="txt", statistics, and error list
    - Use utf-8-sig encoding for Windows BOM compatibility (matching JsonFormatter pattern)
    - Preserve deterministic output (same input chunks → same TXT output every time)
    - Support both concatenated single-file mode and per-chunk file mode
    - Default delimiter: ━━━ CHUNK {{n}} ━━━ (configurable via CLI/config)
    - Strip markdown/HTML artifacts while preserving intentional paragraph spacing
    - Metadata headers optional (--include-metadata flag) with compact format
    - No JSON braces, BOM duplication, or CLI color codes in output
    - Mirror JsonFormatter error handling pattern (catch exceptions, return FormatResult with errors list)
    - Integrate with Epic 5 configuration cascade when available (CLI > env > YAML > defaults)
    - Maintain audit trail: metadata headers must include source_file for traceability
  </constraints>

  <interfaces>
    <interface>
      <name>BaseFormatter.format_chunks</name>
      <kind>protocol-method</kind>
      <signature>def format_chunks(self, chunks: Iterator[Chunk], output_path: Path) -> FormatResult</signature>
      <path>src/data_extract/output/formatters/base.py</path>
      <description>TxtFormatter must implement this method to convert chunk iterator to TXT output file. Method should materialize iterator (required for concatenated mode), generate output with delimiters/headers, write to file, return FormatResult with statistics.</description>
    </interface>
    <interface>
      <name>Chunk.text</name>
      <kind>dataclass-field</kind>
      <signature>text: str</signature>
      <path>src/data_extract/core/models.py</path>
      <description>Primary content to write to TXT output. Must strip markdown/HTML artifacts while preserving paragraph spacing.</description>
    </interface>
    <interface>
      <name>ChunkMetadata.source_file</name>
      <kind>dataclass-field</kind>
      <signature>source_file: Optional[Path]</signature>
      <path>src/data_extract/chunk/models.py</path>
      <description>Source file path for metadata headers and traceability (AC-3.5-3).</description>
    </interface>
    <interface>
      <name>ChunkMetadata.quality</name>
      <kind>dataclass-field</kind>
      <signature>quality: Optional[QualityScore]</signature>
      <path>src/data_extract/chunk/models.py</path>
      <description>Quality scores for metadata headers (overall score for filtering/prioritization).</description>
    </interface>
    <interface>
      <name>ChunkMetadata.entity_tags</name>
      <kind>dataclass-field</kind>
      <signature>entity_tags: List[EntityReference]</signature>
      <path>src/data_extract/chunk/models.py</path>
      <description>Entity references for metadata headers (entity IDs as comma-separated list).</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing follows pytest framework with markers (unit, integration, performance). All formatters require:
      - Unit tests covering core functionality (delimiter rendering, metadata headers, encoding, artifact removal)
      - Integration tests with real chunk data (organization strategies, file structure validation)
      - Performance tests ensuring sub-second formatting for typical documents
      - UAT validation for LLM upload readiness (manual copy/paste to ChatGPT/Claude)

      Story 3.4 established pattern:
      - tests/unit/test_output/test_json_formatter.py (structure, serialization tests)
      - tests/integration/test_output/test_json_output_pipeline.py (end-to-end validation)
      - tests/integration/test_output/test_json_compatibility.py (UTF-8, path compatibility)
      - tests/performance/test_json_performance.py (latency baselines)
    </standards>

    <locations>
      - tests/unit/test_output/test_txt_formatter.py (new - unit tests for TxtFormatter)
      - tests/integration/test_output/test_txt_pipeline.py (new - end-to-end TXT output validation)
      - tests/integration/test_output/test_txt_compatibility.py (new - UTF-8, delimiter, organization tests)
      - tests/performance/test_txt_performance.py (new - formatting latency benchmarks)
      - tests/fixtures/ (reuse existing chunk fixtures from Story 3.4)
    </locations>

    <ideas>
      AC-3.5-1 (Clean Text):
      - Test markdown artifact removal (strip #, *, **, etc. while preserving intentional formatting)
      - Test HTML tag removal (&lt;p&gt;, &lt;div&gt;, etc.)
      - Test whitespace normalization (collapse multiple spaces, preserve paragraph breaks)
      - Test deterministic output (same chunks → byte-identical TXT files)

      AC-3.5-2 (Delimiters):
      - Test default delimiter renders correctly (━━━ CHUNK 001 ━━━)
      - Test delimiter appears between all chunks in concatenated mode
      - Test custom delimiter via config (e.g., "--- CHUNK {{n}} ---")
      - Test chunk numbering (001, 002, 003, etc.)

      AC-3.5-3 (Metadata Headers):
      - Test metadata header format when --include-metadata enabled
      - Test header fields: source file, chunk ID, entity tags, quality score
      - Test header omitted when --include-metadata disabled
      - Test compact header format (1-3 lines max)

      AC-3.5-4 (Organization):
      - Test concatenated mode (single TXT file with all chunks)
      - Test per-chunk mode (separate TXT file per chunk)
      - Test by_document organization (folder per source file)
      - Test by_entity organization (folder per entity type)
      - Test flat organization (all chunks in single directory)

      AC-3.5-5 (Encoding):
      - Test utf-8-sig encoding (BOM present for Windows tools)
      - Test LF newlines by default
      - Test CRLF newlines when configured
      - Test Unicode character preservation (emoji, accents, special chars)

      AC-3.5-6 (Artifacts):
      - Test no BOM duplication (single BOM at start)
      - Test no stray JSON braces ({, }, [, ])
      - Test no CLI color codes (ANSI escape sequences)
      - Test lint validation (zero anomalies detected)

      AC-3.5-7 (LLM Upload):
      - Manual UAT: copy/paste to ChatGPT prompt, verify no cleanup needed
      - Manual UAT: copy/paste to Claude prompt, verify no cleanup needed
      - Integration test: validate chunk text against real fixture data
    </ideas>
  </tests>
</story-context>
